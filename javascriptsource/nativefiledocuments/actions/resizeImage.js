// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE

import ImageResizer from 'react-native-image-resizer';
import NativeFileDocumentsUtils from "../nativefiledocumentsutils";
import RNBlobUtil from "react-native-blob-util";
import { Platform } from 'react-native';
import { create } from "mx-api/data";

// END EXTRA CODE

/**
 * Resize an image using the specified parameters to a new file or base64 encoded image data.
 * @param {string} filepath - The path to the file.
 * @param {"NativeFileDocuments.PathType.FullPath"|"NativeFileDocuments.PathType.DocumentsDirectory"} pathType
 * @param {Big} maxWidth
 * @param {Big} maxHeight
 * @param {"NativeFileDocuments.ResizeImageCompressionFormat.JPEG"|"NativeFileDocuments.ResizeImageCompressionFormat.PNG"|"NativeFileDocuments.ResizeImageCompressionFormat.WEBP"} compressFormat - Can be either JPEG, PNG or WEBP (android only).
 * @param {Big} quality - A number between 0 and 100. Used for the JPEG compression.
 * @param {Big} rotation - Rotation to apply to the image, in degrees, for android. On iOS, rotation is limited (and rounded) to multiples of 90 degrees. Specify 0 for no rotation.
 * @param {boolean} keepMeta - If true, will attempt to preserve all file metadata/exif info, except the orientation value since the resizing also does rotation correction to the original image. Defaults to false, which means all metadata is lost. Note: This can only be true for JPEG images.
 * @param {"NativeFileDocuments.ResizeImageMode.contain"|"NativeFileDocuments.ResizeImageMode.cover"|"NativeFileDocuments.ResizeImageMode.stretch"} resizeMode - Resize mode, either contain, cover, or stretch. contain will fit the image within width and height, preserving its ratio. cover preserves the aspect ratio, and makes sure the image is at least width wide or height tall. stretch will resize the image to exactly width and height.
 * @param {boolean} onlyScaleDown - If true, will never enlarge the image, and will only make it smaller.
 * @param {boolean} writeToLog
 * @returns {Promise.<MxObject>}
 */
export async function resizeImage(filepath, pathType, maxWidth, maxHeight, compressFormat, quality, rotation, keepMeta, resizeMode, onlyScaleDown, writeToLog) {
	// BEGIN USER CODE

	if (!filepath) {
		return Promise.reject(new Error("No file path specified"));
	}

	if (!pathType) {
		return Promise.reject(new Error("No path type specified"));
	}

	if (!maxWidth) {
		return Promise.reject(new Error("No maximum width specified"));
	}
	const maxWidthValue = Number(maxWidth);
	if (maxWidthValue < 0) {
		return Promise.reject(new Error("Invalid maximum width: must be positive"));
	}

	if (!maxHeight) {
		return Promise.reject(new Error("No maximum height specified"));
	}
	const maxHeightValue = Number(maxHeight);
	if (maxHeightValue < 0) {
		return Promise.reject(new Error("Invalid maximum height: must be positive"));
	}

	if (!compressFormat) {
		return Promise.reject(new Error("No compression format specified"));
	}

	if (!quality) {
		return Promise.reject(new Error("No quality specified"));
	}
	const qualityValue = Number(quality);
	if (qualityValue < 0 || qualityValue > 100) {
		return Promise.reject(new Error("Invalid quality value: must be between 0 and 100"));
	}

	if (!rotation) {
		return Promise.reject(new Error("No rotation specified"));
	}
	const rotationValue = Number(rotation);
	if (rotationValue < 0) {
		return Promise.reject(new Error("Invalid rotation: must be positive"));
	}

	if (!resizeMode) {
		return Promise.reject(new Error("No resize mode specified"));
	}

	if (writeToLog) {
		await NativeFileDocumentsUtils.writeToLog({
			actionName: "resizeImage",
			logType: "Parameters",
			logMessage: JSON.stringify({
				filepath: filepath,
				pathType: pathType,
				maxWidth: maxWidthValue,
				maxHeight: maxHeightValue,
				compressFormat: compressFormat,
				quality: qualityValue,
				rotation: rotationValue,
				resizeMode: resizeMode
			})
		});
	}

	const fullPath = NativeFileDocumentsUtils.getFullPathNoPrefix(filepath, pathType, RNBlobUtil, Platform.OS);

	if (writeToLog) {
		await NativeFileDocumentsUtils.writeToLog({
			actionName: "resizeImage",
			logType: "Info",
			logMessage: "Full path: " + fullPath
		});
	}

	const slashPos = fullPath.lastIndexOf("/");
	const outputPath = fullPath.substring(0, slashPos + 1);

	if (writeToLog) {
		await NativeFileDocumentsUtils.writeToLog({
			actionName: "resizeImage",
			logType: "Info",
			logMessage: "Output path: " + outputPath
		});
	}

	const options = {
		mode: resizeMode,
		onlyScaleDown: onlyScaleDown
	};

	try {
		const resizedImageData = await ImageResizer.createResizedImage(
			fullPath,
			maxWidthValue,
			maxHeightValue,
			compressFormat,
			qualityValue,
			rotationValue,
			outputPath,
			keepMeta,
			options
		);

		if (writeToLog) {
			await NativeFileDocumentsUtils.writeToLog({
				actionName: "resizeImage",
				logType: "Info",
				logMessage: JSON.stringify(resizedImageData)
			});
		}

		const resultMxObj = await create({ entity: "NativeFileDocuments.ResizeImageResult"});
		resultMxObj.set("ResizedWidth", resizedImageData.width);
		resultMxObj.set("ResizedHeight", resizedImageData.height);
		resultMxObj.set("Name", resizedImageData.name);
		resultMxObj.set("FilePath", resizedImageData.path);
		return resultMxObj;

	} catch (error) {
		// If this fails, always write a log entry
		await NativeFileDocumentsUtils.writeToLog({
			actionName: "resizeImage",
			logType: "Exception",
			logMessage: JSON.stringify(error)
		});
		return Promise.reject(error)

	};
	// END USER CODE
}
