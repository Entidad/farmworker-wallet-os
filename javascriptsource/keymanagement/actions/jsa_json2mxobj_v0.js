// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE
const keywords=[
	"abstract",
	"assert",
	"boolean",
	"break",
	"byte",
	"case",
	"catch",
	"char",
	"class",
	"const",
	"continue",
	"default",
	"do",
	"double",
	"else",
	"enum",
	"extends",
	"false",
	"final",
	"finally",
	"float",
	"for",
	"if",
	"goto",
	"implements",
	"import",
	"instanceof",
	"int",
	"interface",
	"long",
	"native",
	"new",
	"null",
	"package",
	"private",
	"protected",
	"public",
	"return",
	"short",
	"static",
	"strictfp",
	"super",
	"switch",
	"synchronized",
	"this",
	"throw",
	"throws",
	"transient",
	"true",
	"try",
	"void",
	"volatile",
	"while",
	"currentUser",
	"object",
	"type",
	"guid",
	"id",
	"submetaobjectname",
	"createddate",
	"changeddate",
	"owner",
	"changedby",
	"empty",
	"MendixObject",
	"context",
	"__filename__",
	"con"
];
// END EXTRA CODE

/**
 * Deserializes JSON string to Mendix object
 * JSON field names matching Mendix object attributes will be set.
 * To generalize this javascript action, the output typeparameter can be populated with the desired Mendix object type
 * @param {string} json
 * @param {MxObject} output
 * @returns {Promise.<void>}
 */
export async function jsa_json2mxobj_v0(json, output) {
	// BEGIN USER CODE
	try{
		json=JSON.parse(json);
		//--------------------------------------
		//version 12:00 2023/06/12 - beg
		//--------------------------------------
		output.getAttributes().forEach((attr)=>{
			let attr_=attr;
			//console.info(`attr:${attr}`);
			keywords.forEach((k)=>{
				//postfix: use this only for now
				if(attr==(k+"_")){
					attr_=attr.substring(0,attr.length-1);
				}
			});
			//todo:attempt find attribute by working through permutations for underscores
			//     extant in attribute name, e.g.
			//     mime_type is supposed to try and find mime-type
			//     or mimeType is supposed to try and find mime-type
			//         this last one is more complicated but would be useful
			//     note that for the reverse, jsa_mxobj2json, such detection is not possible
			//     todo: some sort of an override field where you can add your custom mapping
			//           this should also be applied to jsa_mxobj2json
			if(typeof(json[attr_])=="undefined"){
				try{
					let attr__;
					attr__=attr_.replace(/_/g,"-");
					if(typeof(json[attr__])!="undefined"){
						attr_=attr__;
					}else{
						attr__=attr_.split("_").join("");
						if(typeof(json[attr__])!="undefined"){
							attr_=attr__;
						}else{
							attr__=attr_.split("-").reduce((acc,val,idx)=>{return val.length==0?"":idx==0?acc+val:acc+val[0].toUpperCase()+val.length>1?val.substring(1):"";},"");
							if(typeof(json[attr__])!="undefined"){
								attr_=attr__;
							}else{
								attr__=attr_.split("_").reduce((acc,val,idx)=>{return val.length==0?"":idx==0?acc+val:acc+val[0].toUpperCase()+val.length>1?val.substring(1):"";},"");
								if(typeof(json[attr__])!="undefined"){
									attr_=attr__;
								}else{
									return;
								}
							}
						}
					}
				}catch(e){
					console.error(e.toString());
				}
			}
			if(output.isReadonlyAttr(attr)){
				return;
			}
			else if(output.isBoolean(attr)){
				output.set(attr,json[attr_]);
			}
			else if(output.isDate(attr)){
				output.set(attr,new Date(json[attr_]));
			}
			else if(output.isEnum(attr)){
				output.set(attr,json[attr_]);
			}
			else if(output.isLocalizedDate(attr)){
				output.set(attr,new Date(json[attr_]));
			}
			else if(output.isNumeric(attr)){
				output.set(attr,new Big(json[attr_]));
			}
			else if(output.isObjectReference(attr)){
				output.set(attr,json[attr_]);
			}
			else if(output.isObjectReferenceSet(attr)){
				output.set(attr,json[attr_]);
			}
			else if(output.isPassword(attr)){
				output.set(attr,json[attr_]);
			}
			else if(output.isReference(attr)){
			}
			else{//string
				output.set(attr,typeof(json[attr_])=="object"?JSON.stringify(json[attr_]):json[attr_]);
			}
		});
		//--------------------------------------
		//version 12:00 2023/06/12 - end
		//--------------------------------------
		return Promise.resolve();
	}catch(e){
		return Promise.reject(e.toString());
	}
	// END USER CODE
}
