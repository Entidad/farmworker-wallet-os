// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE
import SInfo from "react-native-sensitive-info";
import {jsa_json2mxobj} from"./jsa_json2mxobj.js";
import {jsa_kcorm_get_all_recursive} from"./jsa_kcorm_get_all_recursive.js";
import{default as jsonQuery}from"json-query";
import{mx_data_get_async,mx_data_createAsync,getReverseReferences}from"../support/entidad.js";
// END EXTRA CODE

/**
 * Get all objects of a certain type based on query from the keychain
 * Query language used:
 *     https://github.com/auditassistant/json-query
 * @param {string} key
 * @param {string} query - e.g. Age=42
 * @param {string} entity
 * @param {MxObject[]} output - output list to populate
 * @returns {Promise.<MxObject[]>}
 */
export async function jsa_kcorm_query_recursive(key, query, entity, output) {
	// BEGIN USER CODE
	// --------------
	// IN PROGRESS...
	// --------------
	try{
		if(output==null)return Promise.reject("Argument output null");
		if(key==null)return Promise.reject("Argument key null");
		if(query==null||query.length==0)return jsa_kcorm_get_all_recursive(key,entity,output);//Promise.reject("Argument query null");
		let obj={};
		try{
			//https://mcodex.dev/react-native-sensitive-info/docs/getItem
			let kcval=await SInfo.getItem(key,{});
			if(kcval!=null&&kcval!="")try{
				obj=JSON.parse(kcval);
				obj=typeof(obj)=="object"?obj:Array.isArray(obj)?{}:obj;
			}catch(e){
				console.error(e.toString());
				//todo:handle/log
			}
		}catch(e){
			//todo:handle/log
			console.error(e.toString());
		}
		let module_=entity.split(".")[0];
		if(module_==null||module_=="")return Promise.reject("Invalid entity module name")
		let entity_=entity.split(".")[1];
		if(entity_==null||entity_=="")return Promise.reject("Invalid entity name")
		//throw on module or entity subobjects not found 
		if(typeof(obj[module_])!="object")return Promise.resolve(null);//Promise.reject("Module "+module_+" not found");
		if(typeof(obj[module_][entity_])!="object")return Promise.resolve(null);//return Promise.reject("Entity "+entity_+" not found");
		//query
		let ret=[];
		try{
			query=module_+"."+entity_+"[*]["+query+"]";
			//console.info(query);
			let results=jsonQuery(query,{data:obj,allowRegexp:true});
			if(results==null)return Promise.reject("Failed to query data");
			if(typeof(results.value)=="undefined")return Promise.reject("Invalid query response structure");
			if(results.value==null)return Promise.resolve([]);
			if(!Array.isArray(results.value)){
				results=[results.value]
			}else{
				results=results.value;
			}
			/* original
			for(let i=0;i<results.length;i++){
				let result=results[i];
				let mxobj=await mx_data_createAsync({entity:[module_,entity_].join(".")});
				await jsa_json2mxobj(JSON.stringify(result),mxobj);
				ret.push(mxobj);
			}
			*/
			/*new*/

			for(let i=0;i<results.length;i++){
				let json=results[i];
				let uuid=null;
				      if(json["mxid"]){
					uuid=json["mxid"];
				}else if(json["id_"]){
					uuid=json["id_"];
				}else if(json["_id"]){
					uuid=json["_id"];
				}
				let mxobj=await mx_data_createAsync({entity:[module_,entity_].join(".")});
				await jsa_json2mxobj(JSON.stringify(json),mxobj);
				{//references
					let attributes=mxobj.getAttributes();
					let mob=mx.meta.getMap()[mxobj.getEntity()];
					var refs=mx.meta.getMap()[mxobj.getEntity()].getReferenceAttributes();
					for(var j=0;j<refs.length;j++){
						let k=refs[j];
						try{
							let ref_entity=mx.meta.getMap()[mxobj.getEntity()].getSelectorEntity(k);
							let ref_id=json[k];
							if(ref_id!=null&&ref_id!=""){
								let lookup=obj?.[ref_entity.split(".")[0]]?.[ref_entity.split(".")[1]]?.[ref_id];
								if(typeof(lookup)!="undefined"){
									let mxobjref=await mx_data_createAsync({entity:ref_entity});
									await jsa_json2mxobj(JSON.stringify(lookup),mxobjref);
									mxobj.addReference(k,mxobjref.getGuid());
								}else{
								}
							}
						}catch(e){
							console.error(e.toString());
						}
					}
				}
				{//reverse references
					let rrefs=getReverseReferences(mxobj);
					for(var j=0;j<rrefs.length;j++){
						let rref=rrefs[j];
						let rref_entity=rref.entity;
						let rref_attr=rref.reference;
						let lookups=obj?.[rref_entity.split(".")[0]]?.[rref_entity.split(".")[1]];
						if(typeof(lookups)!="undefined"){
							let lookup=null;
							for(var k=0;k<Object.keys(lookups).length;k++){
								let key=Object.keys(lookups)[k];
								if(lookups[key][rref_attr]==uuid){
									lookup=lookups[key];
									try{
										let mxobjref=await mx_data_createAsync({entity:rref_entity});
										await jsa_json2mxobj(JSON.stringify(lookup),mxobjref);
										mxobjref.addReference(rref_attr,mxobj.getGuid());
									}catch(e){
										console.error(e.toString());
									}
								}
							}
						}else{
							//console.error("no vaiable lookups found");
						}
					}
				}//reverse references - end				
				ret.push(mxobj);
			}






		}catch(e){
			return Promise.reject(e.toString());
		}
		return Promise.resolve(ret);
	}catch(e){
		return Promise.reject(e.toString());
	}
	// END USER CODE
}
